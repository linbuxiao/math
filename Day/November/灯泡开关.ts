// 初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。

// 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。

// 找出并返回 n 轮后有多少个亮着的灯泡。

export function bulbSwitch(n: number): number {
  /**
   * 1.
   * 第一轮全部按一次，第二轮每两个按一次，以此类推。那么 `bulb[i]` 被按的次数将为它的因子个数。
   * 比方 `bulb[8]` 将会在 `[1, 2, 4, 8]` 被按下。最终它是否变亮，则取决于这个个数为奇数，还是偶数。
   * 如果为奇数，则亮，偶数，则灭。
   * 接着我们可以遍历每一个 `bulb[i]` 的 `i` 的因数个数。这时已经可以求解。
   */
  // let count = 0
  // for(let i = 1; i <= n; i++) {
  //   let factor = 0
  //   for(let j = 1; j <= i; j++) {
  //     if(i % j === 0) factor++
  //   }
  //   if(factor % 2 !== 0) count++
  // }
  // return count

  /**
   * 2.
   * 因式分解为两两相乘，`i % j === 0`, 此时 `i` 与 `j` 都为因数，则应当 + 2。
   * 那么只有可以被开方的数，才能让最终的结果为奇数。
   * 所以问题被再次缩略
   */
  // let count = 0
  // for(let i = 1; i <= n; i++) {
  //   const sqrt = Math.sqrt(i)
  //   if(Math.floor(sqrt) === sqrt) count++
  // }
  // return count

  /**
   * 3.
   * 如果是求 `[1, n]` 中的完全平方数数量，则可以用 `sqrt(n).floor()` 来进行
   * 比方说 `100`，开方后为 `10`, 不可能比 `10` 大。
   */

  return Math.floor(Math.sqrt(n));
}
