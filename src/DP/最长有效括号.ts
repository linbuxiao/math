// 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

//

// 示例 1：

// 输入：s = "(()"
// 输出：2
// 解释：最长有效括号子串是 "()"
// 示例 2：

// 输入：s = ")()())"
// 输出：4
// 解释：最长有效括号子串是 "()()"
// 示例 3：

// 输入：s = ""
// 输出：0

// 如果先确定每个位置的最长子串，只排除不合法的，不排除不成对的，这样很容易得到长度。但仍然需要对左括号大小大于右括号的情况进行最大合法值的判断

export function longestValidParentheses(s: string): number {
  if (!s.length) return 0;

  const dp = new Array(s.length).fill(0);

  // (((
  // (()                          (()      (()      ()
  // ()(  -> 只选取结尾为 ) 的情况
  // ())                          ())   -> ())   -> ))
  // )))                          )))

  // 所以我们在dp[i]的位置上，需要关注两种情况，一种`()`，一种`))`

  // 对于这两种情况，我们使用`dp[i]`与`dp[i - 1]`来表示

  // `()`时，需要知道 `- 2` 前是否合法，如果合法，则 `dp[i−2]+2` ，如果不合法，则为`0 + 2`。
  // `))`时，我们需要知道 `dp[i - 1]`是否有合法值。
  // - 如果有合法值，我们只需要 dp[i - 1] + 2即可
  // - 如果无合法值，则我们向前遍历，直到寻找`d`到具有合法值的部分。并且循环判断前方有多少个洋葱对。如果洋葱对的头部与合法值相连，则加上合法值。

  for (let i = 1; i < dp.length; i++) {
    if (s[i - 1] === "(" && s[i] === ")") {
      dp[i] = 2;
      if (i > 1 && dp[i - 2] !== 0) dp[i] = dp[i - 2] + 2;
    }

    if (s[i - 1] === ")" && s[i] === ")") {
      if (dp[i - 1] !== 0 && s[i - dp[i - 1] - 1] === "(") {
        dp[i] = dp[i - 1] + 2;

        if (i - dp[i - 1] - 2 >= 0 && dp[i - dp[i - 1] - 2] !== 0)
          dp[i] += dp[i - dp[i - 1] - 2];
      }
    }
  }

  return Math.max(...dp);
}
